import {Variable, Priority, VarList, Mutations, Util, Readable, Schedulable, Writable, Named, Reaction, Deadline, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor Source in DanglingOutput
// =============== START reactor class Source
class Source extends Reactor {
    t: Timer;
    out: OutPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.t = new Timer(this, 0, 0);
        this.out = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(out: Writable<number>, ) {
                var self = this.parent as Source;
                out.set(1);
            }
        }(this, this.check(this.t, ), this.check(this.getWritable(this.out),)));
    }
}
// =============== END reactor class Source

// Code generated by the Lingua Franca compiler for reactor Gain in DanglingOutput
// =============== START reactor class Gain
class Gain extends Reactor {
    x: InPort<number>;
    out: OutPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.x = new InPort<number>(this);
        this.out = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(x: Readable<number>, out: Writable<number>, ) {
                var self = this.parent as Gain;
                console.log("Received " + x.get());
                out.set((x.get() as number) * 2);
            }
        }(this, this.check(this.x, ), this.check(this.x, this.getWritable(this.out),)));
    }
}
// =============== END reactor class Gain

// Code generated by the Lingua Franca compiler for reactor DanglingOutput in DanglingOutput
// =============== START reactor class DanglingOutput
class DanglingOutput extends App {
    source: Source
    container: Gain
    constructor(name: string, timeout: TimeInterval | null, success?: ()=> void, fail?: ()=>void) {
        super(timeout, success, fail);
        this.source = new Source(this)
        this.container = new Gain(this)
        this._connect(this.source.out, this.container.x);
    }
}
// =============== END reactor class DanglingOutput

// ************* Instance DanglingOutput of class DanglingOutput
let _app = new DanglingOutput('DanglingOutput', null)
// ************* Starting Runtime for DanglingOutput of class DanglingOutput
_app._start();
