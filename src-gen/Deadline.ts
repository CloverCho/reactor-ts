import {Variable, Priority, VarList, Mutations, Util, Readable, Schedulable, Writable, Named, Reaction, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor Source in Deadline
// =============== START reactor class Source
export class Source extends Reactor {
    t: Timer;
    period: TimeInterval; // Parameter
    count: number; // State
    y: OutPort<number>;
    constructor (parent:Reactor, period: TimeInterval = new UnitBasedTimeInterval(1, TimeUnit.sec)) {
        super(parent);
        this.t = new Timer(this, 0, period);
        this.period = period; // Parameter
        this.count = 0; // State
        this.y = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(y: Writable<number>) {
                var self = this.parent as Source;
                if (2 * Math.floor(self.count / 2) != self.count){
                    // The count variable is odd.
                    // Busy wait 0.2 sconds to cause a deadline violation.
                    let initialElapsedTime = self.util.getElapsedPhysicalTime();
                    while ( self.util.getElapsedPhysicalTime().isSmallerThan(initialElapsedTime.add( new UnitBasedTimeInterval(200, TimeUnit.msec))));
                }
                console.log("Source sends: " + self.count);
                y.set(self.count);
                self.count++;
            }
        }(this, this.check(this.t), this.check(this.getWritable(this.y))));
    }
}
// =============== END reactor class Source

// Code generated by the Lingua Franca compiler for reactor Destination in Deadline
// =============== START reactor class Destination
export class Destination extends Reactor {
    timeout: TimeInterval; // Parameter
    count: number; // State
    x: InPort<number>;
    constructor (parent:Reactor, timeout: TimeInterval = new UnitBasedTimeInterval(1, TimeUnit.sec)) {
        super(parent);
        this.timeout = timeout; // Parameter
        this.count = 0; // State
        this.x = new InPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(x: Readable<number>) {
                var self = this.parent as Destination;
                console.log("Destination receives: " + x.get());
                if (2 * Math.floor(self.count / 2) != self.count) {
                    // The count variable is odd, so the deadline should have been violated.
                    console.log("ERROR: Failed to detect deadline.");
                    self.util.failure()
                    //throw new Error("ERROR: Failed to detect deadline.");
                }
                self.count++;
            }
            //@ts-ignore
            late(x: Readable<number>) {
                var self = this.parent as Destination;
                console.log("Destination deadline handler receives: " + x.get());
                if (2 * Math.floor(self.count / 2) == self.count) {
                    // The count variable is even, so the deadline should not have been violated.
                    console.log("ERROR: Deadline miss handler invoked without deadline violation.");
                    self.util.failure()
                    //throw new Error("ERROR: Deadline miss handler invoked without deadline violation.");
                }
                self.count++;
            }
        }(this, this.check(this.x), this.check(this.x)).setDeadline(new UnitBasedTimeInterval(0, TimeUnit.msec)));
    }
}
// =============== END reactor class Destination

// Code generated by the Lingua Franca compiler for reactor Deadline in Deadline
// =============== START reactor class Deadline
export class Deadline extends App {
    s: Source
    d: Destination
    constructor(name: string, timeout: TimeInterval | null, success?: ()=> void, fail?: ()=>void) {
        super(timeout, success, fail);
        this.s = new Source(this, undefined)
        this.d = new Destination(this, new UnitBasedTimeInterval(100, TimeUnit.msec))
        this._connect(this.s.y, this.d.x);
    }
}
// =============== END reactor class Deadline

// ************* Instance Deadline of class Deadline
let _app = new Deadline('Deadline', new UnitBasedTimeInterval(2, TimeUnit.sec))
// ************* Starting Runtime for Deadline of class Deadline
_app._start();
