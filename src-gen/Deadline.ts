import {Readable, Writable, Reaction, Timer, Reactor, OutPort, InPort, App, Triggers, Args, Parameter, State } from "./core/reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval} from "./core/time"
// Code generated by the Lingua Franca compiler for reactor Source in Deadline
// =============== START reactor class Source
export class Source extends Reactor {
    t: Timer;
    period: Parameter<TimeInterval>;
    count: State<number>;
    y: OutPort<number>;
    constructor (parent:Reactor, period: Parameter<TimeInterval> = new Parameter(new UnitBasedTimeInterval(1, TimeUnit.sec))) {
        super(parent);
        this.t = new Timer(this, 0, period.get());
        this.period = period;
        this.count = new State(0);
        this.y = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(y: Writable<number>, count: State<number>) {
                if (2 * Math.floor(count.get() / 2) != count.get()) {
                    // The count variable is odd.
                    // Busy wait 0.2 sconds to cause a deadline violation.
                    let timeToWaitUntil = this.util.time.getElapsedPhysicalTime().add(new UnitBasedTimeInterval(200, TimeUnit.msec));
                    while (this.util.time.getElapsedPhysicalTime().isSmallerThan(timeToWaitUntil));
                }
                console.log("Source sends: " + count.get());
                y.set(count.get());
                count.set(count.get()+1);
            }
        }(this, new Triggers(this.t), new Args(this.getWritable(this.y), this.count)));
    }
}
// =============== END reactor class Source

// Code generated by the Lingua Franca compiler for reactor Destination in Deadline
// =============== START reactor class Destination
export class Destination extends Reactor {
    timeout: Parameter<TimeInterval>;
    count: State<number>;
    x: InPort<number>;
    constructor (parent:Reactor, timeout: Parameter<TimeInterval> = new Parameter(new UnitBasedTimeInterval(1, TimeUnit.sec))) {
        super(parent);
        this.timeout = timeout;
        this.count = new State(0);
        this.x = new InPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(x: Readable<number>, count:State<number>) {
                var self = this.__parent__ as Destination;
                console.log("Destination receives: " + x.get());
                if (2 * Math.floor(count.get() / 2) != count.get()) {
                    // The count variable is odd, so the deadline should have been violated.
                    console.log("ERROR: Failed to detect deadline.");
                    self.util.exec.failure()
                    //throw new Error("ERROR: Failed to detect deadline.");
                }
                count.set(count.get()+1);
            }
            //@ts-ignore
            late(x: Readable<number>, count:State<number>) {
                var self = this.__parent__ as Destination;
                console.log("Destination deadline handler receives: " + x.get());
                if (2 * Math.floor(count.get() / 2) == count.get()) {
                    // The count variable is even, so the deadline should not have been violated.
                    console.log("ERROR: Deadline miss handler invoked without deadline violation.");
                    self.util.exec.failure()
                    //throw new Error("ERROR: Deadline miss handler invoked without deadline violation.");
                }
                count.set(count.get()+1);
            }
        }(this, new Triggers(this.x), new Args(this.x, this.count)).setDeadline(this.timeout.get()));
    }
}
// =============== END reactor class Destination

// Code generated by the Lingua Franca compiler for reactor Deadline in Deadline
// =============== START reactor class Deadline
export class Deadline extends App {
    s: Source
    d: Destination
    constructor(name: string, timeout: TimeInterval | undefined, success?: ()=> void, fail?: ()=>void) {
        super(timeout, false, success, fail);
        this.s = new Source(this, undefined)
        this.d = new Destination(this, new Parameter(new UnitBasedTimeInterval(100, TimeUnit.msec)))
        this._connect(this.s.y, this.d.x);
    }
}
// =============== END reactor class Deadline

// ************* Instance Deadline of class Deadline
let _app = new Deadline('Deadline', new UnitBasedTimeInterval(2, TimeUnit.sec))
// ************* Starting Runtime for Deadline of class Deadline
_app._start();
