import {Args, Present, Parameter, State, Variable, Priority, Mutation, Util, Readable, Schedulable, Triggers, Writable, Named, Reaction, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor Source in Composition
// =============== START reactor class Source
export class Source extends Reactor {
    t: Timer;
    period: Parameter<TimeInterval>;
    count: State<number>;
    y: OutPort<number>;
    constructor (parent:Reactor, period: TimeInterval = new UnitBasedTimeInterval(2, TimeUnit.sec)) {
        super(parent);
        this.t = new Timer(this, new UnitBasedTimeInterval(1, TimeUnit.sec), period);
        this.period = new Parameter(period); // Parameter
        this.count = new State(0);
        this.y = new OutPort<number>(this);
        this.addReaction(
            new Triggers(this.t),
            new Args(this.t, this.getWritable(this.y), this.period, this.count),
            function (this, t: Readable<TimeInstant>, y: Writable<number>, period: Parameter<TimeInterval>, count: State<number>) {
                count.set(count.get() + 1);
                y.set(count.get());
            }
        );
    }
}
// =============== END reactor class Source

// Code generated by the Lingua Franca compiler for reactor Test in Composition
// =============== START reactor class Test
export class Test extends Reactor {
    count: State<number>;
    x: InPort<number>;
    constructor (parent:Reactor) {
        super(parent);
        this.count = new State(0);
        this.x = new InPort<number>(this);
        this.addReaction(
            new Triggers(this.x),
            new Args(this.x, this.count),
            function (this, x: Readable<number>, count: State<number>) {
                count.set(count.get() + 1);
                console.log("Received " + x.get());
                if (x.get() != count.get()) { 
                    console.log("FAILURE: Expected " + count.get());
                    this.util.exec.failure();
                    //throw new Error("FAILURE: Expected " + (this.state as any).count);
                }
            }
        );
    }
}
// =============== END reactor class Test

// Code generated by the Lingua Franca compiler for reactor Composition in Composition
// =============== START reactor class Composition
export class Composition extends App {
    s: Source
    d: Test
    constructor (name: string, timeout: TimeInterval | undefined = undefined, keepAlive: boolean = false, success?: () => void, fail?: () => void) {
        super(timeout, keepAlive, success, fail);
        this.s = new Source(this, undefined)
        this.d = new Test(this)
        this._connect(this.s.y, this.d.x);
    }
}
// =============== END reactor class Composition

// ************* Instance Composition of class Composition
let _app = new Composition('Composition', new UnitBasedTimeInterval(5, TimeUnit.sec))
// ************* Starting Runtime for Composition of class Composition
_app._start();
