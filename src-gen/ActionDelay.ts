import {Variable, Priority, VarList, Mutations, Util, Readable, Schedulable, Writable, Named, Reaction, Deadline, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor GeneratedDelay in ActionDelay
// =============== START reactor class GeneratedDelay
class GeneratedDelay extends Reactor {
    y_state: number; // State
    act: Action<null>;
    y_in: InPort<number>;
    y_out: OutPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.y_state = 0; // State
        this.act = new Action<null>(this, Origin.logical, new UnitBasedTimeInterval(100, TimeUnit.msec));
        this.y_in = new InPort<number>(this);
        this.y_out = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(act: Schedulable<null>, ) {
                var self = this.parent as GeneratedDelay;
                self.y_state = self.y_in.get() as number;
                act.schedule(0);
            }
        }(this, this.check(this.y_in, ), this.check(this.getSchedulable(this.act),)));
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(y_out: Writable<number>, ) {
                var self = this.parent as GeneratedDelay;
                y_out.set(self.y_state);
            }
        }(this, this.check(this.act, ), this.check(this.getWritable(this.y_out),)));
    }
}
// =============== END reactor class GeneratedDelay

// Code generated by the Lingua Franca compiler for reactor Source in ActionDelay
// =============== START reactor class Source
class Source extends Reactor {
    out: OutPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.out = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(out: Writable<number>, ) {
                var self = this.parent as Source;
                out.set(1);
            }
        }(this, this.check(this.startup, ), this.check(this.getWritable(this.out),)));
    }
}
// =============== END reactor class Source

// Code generated by the Lingua Franca compiler for reactor Sink in ActionDelay
// =============== START reactor class Sink
class Sink extends Reactor {
    in: InPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.in = new InPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react() {
                var self = this.parent as Sink;
                var elapsed_logical = self.util.getElapsedLogicalTime();
                var logical = self.util.getCurrentLogicalTime();
                var physical = self.util.getCurrentPhysicalTime();
                console.log("Logical, physical, and elapsed logical: " + logical + physical + elapsed_logical); 
                var oneHundredMsec = new UnitBasedTimeInterval(100, TimeUnit.msec);
                if (!elapsed_logical.isEqualTo(oneHundredMsec)) {
                    console.log("FAILURE: Expected " + oneHundredMsec + " but got " + elapsed_logical);
                    self.util.failure();
                } else {
                    console.log("SUCCESS. Elapsed logical time is " + elapsed_logical);
                }
            }
        }(this, this.check(this.in, ), this.check()));
    }
}
// =============== END reactor class Sink

// Code generated by the Lingua Franca compiler for reactor ActionDelay in ActionDelay
// =============== START reactor class ActionDelay
class ActionDelay extends App {
    source: Source
    sink: Sink
    g: GeneratedDelay
    constructor(name: string, timeout: TimeInterval | null, success?: ()=> void, fail?: ()=>void) {
        super(timeout, success, fail);
        this.source = new Source(this)
        this.sink = new Sink(this)
        this.g = new GeneratedDelay(this)
        this._connect(this.source.out, this.g.y_in);
        this._connect(this.g.y_out, this.sink.in);
    }
}
// =============== END reactor class ActionDelay

// ************* Instance ActionDelay of class ActionDelay
let _app = new ActionDelay('ActionDelay', null)
// ************* Starting Runtime for ActionDelay of class ActionDelay
_app._start();
