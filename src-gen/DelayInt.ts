import {Variable, Priority, VarList, Mutations, Util, Readable, Schedulable, Writable, Named, Reaction, Deadline, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor Delay in DelayInt
// =============== START reactor class Delay
class Delay extends Reactor {
    delay: TimeInterval; // Parameter
    a: Action<number>;
    x: InPort<number>;
    out: OutPort<number>;
    constructor(delay: TimeInterval, parent:Reactor) {
        super(parent);
        this.delay = delay; // Parameter
        this.a = new Action<number>(this, Origin.logical);
        this.x = new InPort<number>(this);
        this.out = new OutPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(x: Readable<number>, a: Schedulable<number>, ) {
                var self = this.parent as Delay;
                let delay = self.delay;
                a.schedule( delay, x.get() as number);
            }
        }(this, this.check(this.x, ), this.check(this.x, this.getSchedulable(this.a),)));
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(a: Readable<number>, out: Writable<number>, ) {
                var self = this.parent as Delay;
                if (a.isPresent()){
                    out.set(a.get())
                }
            }
        }(this, this.check(this.a, ), this.check(this.a, this.getWritable(this.out),)));
    }
}
// =============== END reactor class Delay

// Code generated by the Lingua Franca compiler for reactor Test in DelayInt
// =============== START reactor class Test
class Test extends Reactor {
    start_time: TimeInterval; // State
    received_value: boolean; // State
    x: InPort<number>;
    constructor(parent:Reactor) {
        super(parent);
        this.start_time = new UnitBasedTimeInterval(0, TimeUnit.msec); // State
        this.received_value = false; // State
        this.x = new InPort<number>(this);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react() {
                var self = this.parent as Test;
                // Record the logical time at the start.
                self.start_time = self.util.getCurrentLogicalTime().time;
            }
        }(this, this.check(this.startup, ), this.check()));
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(x: Readable<number>, ) {
                var self = this.parent as Test;
                console.log("Received: " + x.get());
                self.received_value = true;
                // Check the time of the input.
                let current_time = self.util.getCurrentLogicalTime().time;
                let elapsed = current_time.subtract(self.start_time); 
                console.log("After " + elapsed + " of logical time.");
                if ( ! elapsed.isEqualTo(new UnitBasedTimeInterval( 100, TimeUnit.msec))) {
                    console.log("ERROR: Expected elapsed time to be [0, 100000000]. It was " + elapsed);
                    self.util.failure();
                    //throw new Error( "ERROR: Expected elapsed time to be [0, 100000000]. It was " + elapsed);
                }
                if ( x.get() != 42) {
                    console.log("ERROR: Expected input value to be 42. It was " + x.get());
                    self.util.failure();
                    //throw new Error("ERROR: Expected input value to be 42. It was " + (this.state as any).x.get());            
                }
            }
        }(this, this.check(this.x, ), this.check(this.x, )));
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react() {
                var self = this.parent as Test;
                console.log("Checking that communication occurred.");
                if (! self.received_value) {
                    console.log("ERROR: No communication occurred!");
                    self.util.failure();
                    //throw new Error("ERROR: No communication occurred!");          
                }
            }
        }(this, this.check(this.shutdown, ), this.check()));
    }
}
// =============== END reactor class Test

// Code generated by the Lingua Franca compiler for reactor DelayInt in DelayInt
// =============== START reactor class DelayInt
class DelayInt extends App {
    d: Delay
    t: Test
    constructor(name: string, timeout: TimeInterval | null, success?: ()=> void, fail?: ()=>void) {
        super(timeout, success, fail);
        this.d = new Delay(new UnitBasedTimeInterval(100, TimeUnit.msec), this)
        this.t = new Test(this)
        this._connect(this.d.out, this.t.x);
        this.addReaction(new class<T> extends Reaction<T> {
            //@ts-ignore
            react(d: { x: Writable,  }, ) {
                var self = this.parent as DelayInt;
                d.x.set(42);
            }
        }(this, this.check(this.startup, ), this.check({ x: this.getWritable(this.d.x),  }, )));
    }
}
// =============== END reactor class DelayInt

// ************* Instance DelayInt of class DelayInt
let _app = new DelayInt('DelayInt', null)
// ************* Starting Runtime for DelayInt of class DelayInt
_app._start();
