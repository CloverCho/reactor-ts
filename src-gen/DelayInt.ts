import {Args, Present, Parameter, State, Variable, Priority, Mutation, Util, Readable, Schedulable, Triggers, Writable, Named, Reaction, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit,TimeInterval, UnitBasedTimeInterval, TimeInstant, Origin, getCurrentPhysicalTime } from "./time"
// Code generated by the Lingua Franca compiler for reactor Delay in DelayInt
// =============== START reactor class Delay
export class Delay extends Reactor {
    delay: Parameter<TimeInterval>;
    a: Action<number>;
    x: InPort<number>;
    out: OutPort<number>;
    constructor (parent:Reactor, delay: TimeInterval = new UnitBasedTimeInterval(100, TimeUnit.msec)) {
        super(parent);
        this.delay = new Parameter(delay); // Parameter
        this.a = new Action<number>(this, Origin.logical);
        this.x = new InPort<number>(this);
        this.out = new OutPort<number>(this);
        this.addReaction(
            new Triggers(this.x),
            new Args(this.x, this.getSchedulable(this.a), this.delay),
            function (this, x: Readable<number>, a: Schedulable<number>, delay: Parameter<TimeInterval>) {
                a.schedule( delay.get(), x.get() as number);
            }
        );
        this.addReaction(
            new Triggers(this.a),
            new Args(this.a, this.getWritable(this.out), this.delay),
            function (this, a: Readable<number>, out: Writable<number>, delay: Parameter<TimeInterval>) {
                if (a.get() !== null){
                    out.set(a.get() as number)
                }
            }
        );
    }
}
// =============== END reactor class Delay

// Code generated by the Lingua Franca compiler for reactor Test in DelayInt
// =============== START reactor class Test
export class Test extends Reactor {
    start_time: State<TimeInterval>;
    received_value: State<boolean>;
    x: InPort<number>;
    constructor (parent:Reactor) {
        super(parent);
        this.start_time = new State(new UnitBasedTimeInterval(0, TimeUnit.msec));
        this.received_value = new State(false);
        this.x = new InPort<number>(this);
        this.addReaction(
            new Triggers(this.startup),
            new Args(this.start_time, this.received_value),
            function (this, start_time: State<TimeInterval>, received_value: State<boolean>) {
                // Record the logical time at the start.
                start_time.set(this.util.time.getCurrentLogicalTime().time);
            }
        );
        this.addReaction(
            new Triggers(this.x),
            new Args(this.x, this.start_time, this.received_value),
            function (this, x: Readable<number>, start_time: State<TimeInterval>, received_value: State<boolean>) {
                console.log("Received: " + x.get());
                received_value.set(true);
                // Check the time of the input.
                let current_time = this.util.time.getCurrentLogicalTime().time;
                let elapsed = current_time.subtract(start_time.get()); 
                console.log("After " + elapsed + " of logical time.");
                if ( ! elapsed.isEqualTo(new UnitBasedTimeInterval( 100, TimeUnit.msec))) {
                    console.log("ERROR: Expected elapsed time to be [0, 100000000]. It was " + elapsed);
                    this.util.exec.failure();
                    //throw new Error( "ERROR: Expected elapsed time to be [0, 100000000]. It was " + elapsed);
                }
                if ( x.get() != 42) {
                    console.log("ERROR: Expected input value to be 42. It was " + x.get());
                    this.util.exec.failure();
                    //throw new Error("ERROR: Expected input value to be 42. It was " + (this.state as any).x.get());            
                }
            }
        );
        this.addReaction(
            new Triggers(this.shutdown),
            new Args(this.start_time, this.received_value),
            function (this, start_time: State<TimeInterval>, received_value: State<boolean>) {
                console.log("Checking that communication occurred.");
                if (! received_value) {
                    console.log("ERROR: No communication occurred!");
                    this.util.exec.failure();
                    //throw new Error("ERROR: No communication occurred!");          
                }
            }
        );
    }
}
// =============== END reactor class Test

// Code generated by the Lingua Franca compiler for reactor DelayInt in DelayInt
// =============== START reactor class DelayInt
export class DelayInt extends App {
    d: Delay
    t: Test
    constructor (name: string, timeout: TimeInterval | undefined = undefined, keepAlive: boolean = false, success?: () => void, fail?: () => void) {
        super(timeout, keepAlive, success, fail);
        this.d = new Delay(this, undefined)
        this.t = new Test(this)
        this._connect(this.d.out, this.t.x);
        this.addReaction(
            new Triggers(this.startup),
            new Args({ x: this.getWritable(this.d.x) }),
            function (this, d: { x: Writable<number> }) {
                d.x.set(42);
            }
        );
    }
}
// =============== END reactor class DelayInt

// ************* Instance DelayInt of class DelayInt
let _app = new DelayInt('DelayInt')
// ************* Starting Runtime for DelayInt of class DelayInt
_app._start();
