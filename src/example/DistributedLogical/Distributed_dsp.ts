// Code generated by the Lingua Franca compiler from file:
// /Users/matt.weber/git/lingua-franca/example/DistributedTS/Distributed.lf
import commandLineArgs from 'command-line-args'
import commandLineUsage from 'command-line-usage'
import {Args, Present, Parameter, State, Variable, Priority, Mutation, Read, Triggers, ReadWrite, Write, Named, Reaction, Action, Startup, Schedule, Timer, Reactor, Port, OutPort, InPort, App, FederatedApp} from './reactor'
import {TimeUnit, TimeValue, UnitBasedTimeValue, Tag, Origin} from './time'
import {Log} from './util'
import {ProcessedCommandLineArgs, CommandLineOptionDefs, CommandLineUsageDefs, CommandLineOptionSpec, unitBasedTimeValueCLAType, booleanCLAType} from './cli'

// ************* App Parameters
let __timeout: TimeValue | undefined = new UnitBasedTimeValue(10, TimeUnit.secs);
let __keepAlive: boolean = true;
let __fast: boolean = false;

let __noStart = false; // If set to true, don't start the app.

// ************* Custom Command Line Arguments
let __additionalCommandLineArgs : CommandLineOptionSpec = [
];
let __customCommandLineArgs = CommandLineOptionDefs.concat(__additionalCommandLineArgs);
let __customCommandLineUsageDefs = CommandLineUsageDefs;
type __customCLTypeExtension = {};
__customCommandLineUsageDefs[1].optionList = __customCommandLineArgs;
const __clUsage = commandLineUsage(__customCommandLineUsageDefs);
             
// Set App parameters using values from the constructor or command line args.
// Command line args have precedence over values from the constructor
let __processedCLArgs: ProcessedCommandLineArgs & __customCLTypeExtension;
try {
    __processedCLArgs =  commandLineArgs(__customCommandLineArgs) as ProcessedCommandLineArgs & __customCLTypeExtension;
} catch (e){
    Log.global.error(__clUsage);
    throw new Error("Command line argument parsing failed with: " + e);
}

// Fast Parameter
if (__processedCLArgs.fast !== undefined) {
    if (__processedCLArgs.fast !== null) {
        __fast = __processedCLArgs.fast;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'fast' command line argument is malformed.");
    }
}

// KeepAlive parameter
if (__processedCLArgs.keepalive !== undefined) {
    if (__processedCLArgs.keepalive !== null) {
        __keepAlive = __processedCLArgs.keepalive;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'keepalive' command line argument is malformed.");
    }
}

// Timeout parameter
if (__processedCLArgs.timeout !== undefined) {
    if (__processedCLArgs.timeout !== null) {
        __timeout = __processedCLArgs.timeout;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'timeout' command line argument is malformed.");
    }
}

// Logging parameter (not a constructor parameter, but a command line option)
if (__processedCLArgs.logging !== undefined) {
    if (__processedCLArgs.logging !== null) {
        Log.global.level = __processedCLArgs.logging;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'logging' command line argument is malformed.");
    }
} else {
    Log.global.level = Log.levels.ERROR; // Default from target property.
}

// Help parameter (not a constructor parameter, but a command line option)
// NOTE: this arg has to be checked after logging, because the help mode should
// suppress debug statements from it changes logging
if (__processedCLArgs.help === true) {
    Log.global.error(__clUsage);
    __noStart = true;
    // Don't execute the app if the help flag is given.
}

// Now the logging property has been set to its final value,
// log information about how command line arguments were set,
// but only if not in help mode.

// Runtime command line arguments 
if (__processedCLArgs.fast !== undefined && __processedCLArgs.fast !== null
    && !__noStart) {
    Log.global.info("'fast' property overridden by command line argument.");
}
if (__processedCLArgs.keepalive !== undefined && __processedCLArgs.keepalive !== null
    && !__noStart) {
    Log.global.info("'keepalive' property overridden by command line argument.");
}
if (__processedCLArgs.timeout !== undefined && __processedCLArgs.timeout !== null
    && !__noStart) {
    Log.global.info("'timeout' property overridden by command line argument.");
}
if (__processedCLArgs.logging !== undefined && __processedCLArgs.logging !== null
    && !__noStart) {
     Log.global.info("'logging' property overridden by command line argument.");
}

// Custom command line arguments

// Assign custom command line arguments
// =============== START reactor class MessageGenerator
export class MessageGenerator extends Reactor {
    t: Timer;
    root: Parameter<string>;
    count: State<number>;
    message: OutPort<string>;
    constructor (
        parent: Reactor, 
        root: string = ""
    ) {
        super(parent);
        this.t = new Timer(this, new UnitBasedTimeValue(1, TimeUnit.sec), new UnitBasedTimeValue(1, TimeUnit.sec));
        this.root = new Parameter(root);
        this.count = new State(1);
        this.message = new OutPort<string>(this);
        this.addReaction(
            new Triggers(this.t),
            new Args(this.t, this.getWriter(this.message), this.root, this.count),
            function (this, __t: Read<Tag>, __message: ReadWrite<string>, __root: Parameter<string>, __count: State<number>) {
                // =============== START react prologue
                const util = this.util;
                let t = __t.get();
                let message = __message.get();
                let root = __root.get();
                let count = __count.get();
                // =============== END react prologue
                try {
                    message = count.toString();    
                    console.log(`At time ${util.getElapsedLogicalTime()}, send message: ${count++}`);
                    
                    //        // With NULL, 0 arguments, snprintf tells us how many bytes are needed.
                    //        // Add one for the null terminator.
                    //        int length = snprintf(NULL, 0, "%s %d", self->root, self->count) + 1;
                    //        // Dynamically allocate memory for the output.
                    //        set_new_array(message, length);
                    //        // Populate the output string and increment the count.
                    //        snprintf(message, length, "%s %d", self->root, self->count++);
                    //        printf("MessageGenerator: At time %lld, send message: %s\n",
                    //            get_elapsed_logical_time(),
                    //            message
                    //        );
                        
                } finally {
                    // =============== START react epilogue
                    if (message !== undefined) {
                        __message.set(message);
                    }
                    if (count !== undefined) {
                        __count.set(count);
                    }
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class MessageGenerator

// =============== START reactor class PrintMessage
export class PrintMessage extends Reactor {
    message: InPort<string>;
    constructor (
        parent: Reactor
    ) {
        super(parent);
        this.message = new InPort<string>(this);
        this.addReaction(
            new Triggers(this.message),
            new Args(this.message),
            function (this, __message: Read<string>) {
                // =============== START react prologue
                const util = this.util;
                let message = __message.get();
                // =============== END react prologue
                try {
                    console.log(`PrintMessage: At (elapsed) logical time ${util.getElapsedLogicalTime()}, receiver receives: ${message}`);
                    //        printf("PrintMessage: At (elapsed) logical time %lld, receiver receives: %s\n",
                    //            get_elapsed_logical_time(),
                    //            message
                    //        );
                        
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class PrintMessage

// =============== START reactor class Distributed
export class Distributed extends FederatedApp {
    dsp: PrintMessage
    networkMessage: Action<string>;
    constructor (
        timeout: TimeValue | undefined = undefined, 
        keepAlive: boolean = false, 
        fast: boolean = false, 
        success?: () => void, 
        fail?: () => void
    ) {
        super(1, 15044, "localhost", timeout, keepAlive, fast, success, fail);
        this.dsp = new PrintMessage(this)
        this.networkMessage = new Action<string>(this, Origin.logical, new UnitBasedTimeValue(10, TimeUnit.msec));
        this.registerFederatePortAction(0, this.networkMessage);
        this.addReaction(
            new Triggers(this.networkMessage),
            new Args(this.networkMessage, this.getWriter(this.dsp.message)),
            function (this, __networkMessage: Read<string>, __dsp_message: ReadWrite<string>) {
                // =============== START react prologue
                const util = this.util;
                let networkMessage = __networkMessage.get();
                let dsp = {message: __dsp_message.get()}
                // =============== END react prologue
                try {
                    // FIXME: For now assume the data is a string, but this is not checked.
                    // Replace with ProtoBufs or MessagePack.
                    if (networkMessage !== undefined) {
                        dsp.message = networkMessage.toString(); // defaults to utf8 encoding
                    }
                } finally {
                    // =============== START react epilogue
                    if (dsp.message !== undefined) {
                        __dsp_message.set(dsp.message)
                    }
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Distributed

// ************* Instance Distributed of class Distributed
let __app;
if (!__noStart) {
    __app = new Distributed(__timeout, __keepAlive, __fast, );
}
// ************* Starting Runtime for Distributed + of class Distributed.
if (!__noStart && __app) {
    __app._start();
}
